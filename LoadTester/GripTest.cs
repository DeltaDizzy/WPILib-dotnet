//using System;
//using System.Collections.Generic;
//using OpenCvSharp;

///*
//using WPILib.Vision;



///**
//* GripPipeline class.
//*
//* <p>An OpenCV pipeline generated by GRIP.
//*
//* @author GRIP
//*/
//public class GripPipeline : VisionPipeline
//{

//    //Outputs
//    private Mat cvFlipOutput = new Mat();
//    private Mat blurOutput = new Mat();
//    private Mat hsvThreshold0Output = new Mat();
//    private List<MatOfPoint> findContours0Output = new List<MatOfPoint>();
//    private List<MatOfPoint> convexHulls0Output = new List<MatOfPoint>();
//    private List<MatOfPoint> filterContoursOutput = new List<MatOfPoint>();
//    private Mat hsvThreshold1Output = new Mat();
//    private List<MatOfPoint> findContours1Output = new List<MatOfPoint>();
//    private List<MatOfPoint> convexHulls1Output = new List<MatOfPoint>();


//    /**
//	 * This is the primary method that runs the entire pipeline and updates the outputs.
//	 */
//    public void process(Mat source0)
//    {
//        // Step CV_flip0:
//        Mat cvFlipSrc = source0;
//        FlipCode cvFlipFlipcode = FlipCode.Y_AXIS;
//        cvFlip(cvFlipSrc, cvFlipFlipcode, cvFlipOutput);

//        // Step Blur0:
//        Mat blurInput = cvFlipOutput;
//        BlurType blurType = BlurType.get("Gaussian Blur");
//        double blurRadius = 12.612612612612613;
//        blur(blurInput, blurType, blurRadius, blurOutput);

//        // Step HSV_Threshold0:
//        Mat hsvThreshold0Input = blurOutput;
//        double[] hsvThreshold0Hue = { 0.0, 41.774744027303754 };
//        double[] hsvThreshold0Saturation = { 77.96762589928058, 255.0 };
//        double[] hsvThreshold0Value = { 176.57374100719423, 255.0 };
//        hsvThreshold(hsvThreshold0Input, hsvThreshold0Hue, hsvThreshold0Saturation, hsvThreshold0Value, hsvThreshold0Output);

//        // Step Find_Contours0:
//        Mat findContours0Input = hsvThreshold0Output;
//        boolean findContours0ExternalOnly = false;
//        findContours(findContours0Input, findContours0ExternalOnly, findContours0Output);

//        // Step Convex_Hulls0:
//        List<MatOfPoint> convexHulls0Contours = findContours0Output;
//        convexHulls(convexHulls0Contours, convexHulls0Output);

//        // Step Filter_Contours0:
//        List<MatOfPoint> filterContoursContours = convexHulls0Output;
//        double filterContoursMinArea = 5000.0;
//        double filterContoursMinPerimeter = 0.0;
//        double filterContoursMinWidth = 0.0;
//        double filterContoursMaxWidth = 1000.0;
//        double filterContoursMinHeight = 0.0;
//        double filterContoursMaxHeight = 1000.0;
//        double[] filterContoursSolidity = { 0, 100 };
//        double filterContoursMaxVertices = 1000000.0;
//        double filterContoursMinVertices = 0.0;
//        double filterContoursMinRatio = 0.0;
//        double filterContoursMaxRatio = 1000.0;
//        filterContours(filterContoursContours, filterContoursMinArea, filterContoursMinPerimeter, filterContoursMinWidth, filterContoursMaxWidth, filterContoursMinHeight, filterContoursMaxHeight, filterContoursSolidity, filterContoursMaxVertices, filterContoursMinVertices, filterContoursMinRatio, filterContoursMaxRatio, filterContoursOutput);

//        // Step HSV_Threshold1:
//        Mat hsvThreshold1Input = blurOutput;
//        double[] hsvThreshold1Hue = { 93.88489208633094, 115.49488054607508 };
//        double[] hsvThreshold1Saturation = { 66.50179856115108, 239.76962457337885 };
//        double[] hsvThreshold1Value = { 0.0, 255.0 };
//        hsvThreshold(hsvThreshold1Input, hsvThreshold1Hue, hsvThreshold1Saturation, hsvThreshold1Value, hsvThreshold1Output);

//        // Step Find_Contours1:
//        Mat findContours1Input = hsvThreshold1Output;
//        boolean findContours1ExternalOnly = false;
//        findContours(findContours1Input, findContours1ExternalOnly, findContours1Output);

//        // Step Convex_Hulls1:
//        List<MatOfPoint> convexHulls1Contours = findContours1Output;
//        convexHulls(convexHulls1Contours, convexHulls1Output);

//    }

//    /**
//	 * This method is a generated getter for the output of a CV_flip.
//	 * @return Mat output from CV_flip.
//	 */
//    public Mat GetcvFlipOutput()
//    {
//        return cvFlipOutput;
//    }

//    /**
//	 * This method is a generated getter for the output of a Blur.
//	 * @return Mat output from Blur.
//	 */
//    public Mat GetblurOutput()
//    {
//        return blurOutput;
//    }

//    /**
//	 * This method is a generated getter for the output of a HSV_Threshold.
//	 * @return Mat output from HSV_Threshold.
//	 */
//    public Mat GethsvThreshold0Output()
//    {
//        return hsvThreshold0Output;
//    }

//    /**
//	 * This method is a generated getter for the output of a Find_Contours.
//	 * @return List<MatOfPoint> output from Find_Contours.
//	 */
//    public List<MatOfPoint> GetfindContours0Output()
//    {
//        return findContours0Output;
//    }

//    /**
//	 * This method is a generated getter for the output of a Convex_Hulls.
//	 * @return List<MatOfPoint> output from Convex_Hulls.
//	 */
//    public List<MatOfPoint> GetconvexHulls0Output()
//    {
//        return convexHulls0Output;
//    }

//    /**
//	 * This method is a generated getter for the output of a Filter_Contours.
//	 * @return List<MatOfPoint> output from Filter_Contours.
//	 */
//    public List<MatOfPoint> GetfilterContoursOutput()
//    {
//        return filterContoursOutput;
//    }

//    /**
//	 * This method is a generated getter for the output of a HSV_Threshold.
//	 * @return Mat output from HSV_Threshold.
//	 */
//    public Mat GethsvThreshold1Output()
//    {
//        return hsvThreshold1Output;
//    }

//    /**
//	 * This method is a generated getter for the output of a Find_Contours.
//	 * @return List<MatOfPoint> output from Find_Contours.
//	 */
//    public List<MatOfPoint> GetfindContours1Output()
//    {
//        return findContours1Output;
//    }

//    /**
//	 * This method is a generated getter for the output of a Convex_Hulls.
//	 * @return List<MatOfPoint> output from Convex_Hulls.
//	 */
//    public List<MatOfPoint> GetconvexHulls1Output()
//    {
//        return convexHulls1Output;
//    }


//    /**
//	 * Flips an image along X, Y or both axes.
//	 * @param src Image to flip.
//	 * @param flipcode FlipCode of which direction to flip.
//	 * @param dst flipped version of the Image.
//	 */
//    private void cvFlip(Mat src, FlipMode flipmode, Mat dst)
//    {
//        Cv2.Flip(src, dst, flipmode);
//    }

//    enum BlurType
//    {
//        Bilateral,
//        Box,
//        Gaussian,
//        Median
//    }

//    private void blur(Mat input, BlurType type, double dradius, Mat output)
//    {
//        int radius = (int)(dradius + 0.5);
//        int kernalSize;
//        switch (type)
//        {
//            case BlurType.Bilateral:
//                Cv2.BilateralFilter(input, output, -1, radius, radius);
//                break;
//            case BlurType.Box:
//                kernalSize = 2 * radius + 1;
//                Cv2.Blur(input, output, new Size(kernalSize, kernalSize));
//                break;
//            case BlurType.Gaussian:
//                kernalSize = 6 * radius + 1;
//                Cv2.GaussianBlur(input, output, new Size(kernalSize, kernalSize), radius);
//                break;
//            case BlurType.Median:
//                kernalSize = 2 * radius + 1;
//                Cv2.MedianBlur(input, output, kernalSize);
//                break;
//            default:
//                throw new ArgumentOutOfRangeException(nameof(type), type, null);
//        }
//    }


//    /**
//	 * Filters out contours that do not meet certain criteria.
//	 * @param inputContours is the input list of contours
//	 * @param output is the the output list of contours
//	 * @param minArea is the minimum area of a contour that will be kept
//	 * @param minPerimeter is the minimum perimeter of a contour that will be kept
//	 * @param minWidth minimum width of a contour
//	 * @param maxWidth maximum width
//	 * @param minHeight minimum height
//	 * @param maxHeight maximimum height
//	 * @param Solidity the minimum and maximum solidity of a contour
//	 * @param minVertexCount minimum vertex Count of the contours
//	 * @param maxVertexCount maximum vertex Count
//	 * @param minRatio minimum ratio of width to height
//	 * @param maxRatio maximum ratio of width to height
//	 */
//    private void filterContours(List<MatOfPoint> inputContours, double minArea,
//        double minPerimeter, double minWidth, double maxWidth, double minHeight, double
//        maxHeight, double[] solidity, double maxVertexCount, double minVertexCount, double
//        minRatio, double maxRatio, List<MatOfPoint> output)
//    {
//        MatOfPoint hull = new MatOfPoint();
//        output.Clear();
//        foreach (MatOfPoint contour in inputContours)
//        {
//            Rect bb = Cv2.BoundingRect((InputArray)contour);
//            if (bb.Width < minWidth || bb.Width > maxWidth) continue;
//            if (bb.Height < minHeight || bb.Height > maxHeight) continue;
//            double area = Cv2.ContourArea((InputArray)contour);
//            if (area < minArea) continue;
//            if (Cv2.ArcLength((InputArray)contour, true) < minPerimeter) continue;
//            Cv2.ConvexHull(contour, hull);
//            double solid = 100 * area / Cv2.ContourArea((InputArray)hull);
//            if (solid < solidity[0] || solid > solidity[1]) continue;
//            if (contour.Rows < minVertexCount || contour.Rows > maxVertexCount) continue;
//            double ratio = bb.Width / (double)bb.Height;
//            if (ratio < minRatio || ratio > maxRatio) continue;
//            output.Add(contour);
//        }
//    }

//    /**
//	 * Segment an image based on hue, saturation, and value ranges.
//	 *
//	 * @param input The image on which to perform the HSL threshold.
//	 * @param hue The min and max hue
//	 * @param sat The min and max saturation
//	 * @param val The min and max value
//	 * @param output The image in which to store the output.
//	 */
//    private void hsvThreshold(Mat input, double[] hue, double[] sat, double[] val,
//        Mat output)
//    {
//        Cv2.CvtColor(input, output, ColorConversionCodes.BGR2HSV);
//        Cv2.InRange(output, new Scalar(hue[0], sat[0], val[0]),
//            new Scalar(hue[1], sat[1], val[1]), output);
//    }

//    /**
//	 * Sets the values of pixels in a binary image to their distance to the nearest black pixel.
//	 * @param input The image on which to perform the Distance Transform.
//	 * @param type The Transform.
//	 * @param maskSize the size of the mask.
//	 * @param output The image in which to store the output.
//	 */
//    private void findContours(Mat input, bool externalOnly,
//        List<MatOfPoint> contours)
//    {
//        contours.Clear();
//    RetrievalModes mode = externalOnly ? RetrievalModes.External : RetrievalModes.List;
//    ContourApproximationModes method = ContourApproximationModes.ApproxSimple;
//    Cv2.FindContours(input, contours, mode, method);
//	}

///**
// * Compute the convex hulls of contours.
// * @param inputContours The contours on which to perform the operation.
// * @param outputContours The contours where the output will be stored.
// */
//private void convexHulls(List<MatOfPoint> inputContours,
//    List<MatOfPoint> outputContours)
//{
//    outputContours.Clear();
//    outputContours.Capacity = inputContours.Count;
//    foreach (MatOfPoint points in inputContours)
//    {
//        Mat mat = new Mat();
//        Cv2.ConvexHull(points, mat);
//        outputContours.Add(new MatOfPoint(mat));
//    }
//}
//	}



//}


